<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [BulmaGés] [Gitorious] Activity: tborras pushed 2	commits to release...
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/bulmages-main/2012-May/index.html" >
   <LINK REL="made" HREF="mailto:bulmages-main%40lists.berlios.de?Subject=Re%3A%20%3D%3Futf-8%3Fb%3FW0J1bG1hR8Opc10%3D%3F%3D%20%5BGitorious%5D%20Activity%3A%20tborras%20pushed%202%0A%09commits%20to%20release...&In-Reply-To=%3C20120506215228.B4D57756D7%40steelheart.shortcut.kunder.linpro.no%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <LINK REL="Previous"  HREF="007177.html">
   <LINK REL="Next"  HREF="007179.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[BulmaGés] [Gitorious] Activity: tborras pushed 2	commits to release... </H1>
    <B>Gitorious</B> 
    <A HREF="mailto:bulmages-main%40lists.berlios.de?Subject=Re%3A%20%3D%3Futf-8%3Fb%3FW0J1bG1hR8Opc10%3D%3F%3D%20%5BGitorious%5D%20Activity%3A%20tborras%20pushed%202%0A%09commits%20to%20release...&In-Reply-To=%3C20120506215228.B4D57756D7%40steelheart.shortcut.kunder.linpro.no%3E"
       TITLE="[BulmaGés] [Gitorious] Activity: tborras pushed 2	commits to release...">no-reply en gitorious.org
       </A><BR>
    <I>Dom Mayo  6 23:52:28 CEST 2012</I>
    <P><UL>
        <LI>Mensaje anterior: <A HREF="007177.html">[BulmaGés] [Gitorious] Activity: tborras pushed 1	commits to master...
</A></li>
        <LI>Próximo mensaje: <A HREF="007179.html">[BulmaGés] Commits en la lista
</A></li>
         <LI> <B>Mensajes ordenados por:</B> 
              <a href="date.html#7178">[ fecha ]</a>
              <a href="thread.html#7178">[ hilo ]</a>
              <a href="subject.html#7178">[ asunto ]</a>
              <a href="author.html#7178">[ autor ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>

Hello bulmagesmailing,

One of your favorites has a new activity:
------------------------------------------------------------------------
tborras pushed 2 commits to release
release changed from 3267088 to 3a4fa1c

View the commit log at <A HREF="https://gitorious.org/bulmages/bulmages/commits">https://gitorious.org/bulmages/bulmages/commits</A>

View the diff online: <A HREF="https://gitorious.org/bulmages/bulmages/commit/32670885912177ebce22fbcfe3c52170004bbf9b/diffs/3a4fa1c0f26bd20e7d81d21764b2897347c3ad89">https://gitorious.org/bulmages/bulmages/commit/32670885912177ebce22fbcfe3c52170004bbf9b/diffs/3a4fa1c0f26bd20e7d81d21764b2897347c3ad89</A>

Diff: 

commit 3a4fa1c0f26bd20e7d81d21764b2897347c3ad89
Author: Tomeu Borras &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bulmages-main">tborras en conetxia.com</A>&gt;
Date:   Sun May 6 23:43:36 2012 +0200

    Importo cambios menores de la rama master que crean conflictos.

diff --git a/bulmages/installbulmages/bulmages.conf.in b/bulmages/installbulmages/bulmages.conf.in
index f0bc43e..b5551d2 100644
--- a/bulmages/installbulmages/bulmages.conf.in
+++ b/bulmages/installbulmages/bulmages.conf.in
@@ -110,7 +110,6 @@ CONF_ASK_BEFORE_EXIT			TRUE
 # Si se tiene el VisorHTML Instalado esta es la URL que hay que visitar
 CONF_URL_CONTENTS		<A HREF="http://www.iglues.org/mini">http://www.iglues.org/mini</A>
 
-
 # Usar QScript (llamar a los archivos .qs de openreports)
 CONF_USE_QSCRIPT                        FALSE
 
diff --git a/nsis_bulmages/NSIS_includes_comunes/pluginbl/include_install_pluginbl_register.nsh~ b/nsis_bulmages/NSIS_includes_comunes/pluginbl/include_install_pluginbl_register.nsh~
deleted file mode 100644
index 03f4e38..0000000
--- a/nsis_bulmages/NSIS_includes_comunes/pluginbl/include_install_pluginbl_register.nsh~
+++ /dev/null
@@ -1 +0,0 @@
-!insertmacro InstallFilesFromBuild libpluginbl_register.dll &quot;\bulmalib\plugins\pluginbl_logo\libpluginbl_register.dll&quot;
diff --git a/nsis_bulmages/NSIS_includes_comunes/python/Python26/Lib/site-packages/reportlab/pdfbase/ttfonts.py~ b/nsis_bulmages/NSIS_includes_comunes/python/Python26/Lib/site-packages/reportlab/pdfbase/ttfonts.py~
deleted file mode 100644
index e044c90..0000000
--- a/nsis_bulmages/NSIS_includes_comunes/python/Python26/Lib/site-packages/reportlab/pdfbase/ttfonts.py~
+++ /dev/null
@@ -1,1135 +0,0 @@
-#Copyright ReportLab Europe Ltd. 2000-2009
-#see license.txt for license details
-__version__ = '$Id: ttfonts.py 3608 2009-12-04 16:12:34Z rgbecker $'
-__doc__=&quot;&quot;&quot;TrueType font support
-
-This defines classes to represent TrueType fonts.  They know how to calculate
-their own width and how to write themselves into PDF files.  They support
-subsetting and embedding and can represent all 16-bit Unicode characters.
-
-Note on dynamic fonts
----------------------
-
-Usually a Font in ReportLab corresponds to a fixed set of PDF objects (Font,
-FontDescriptor, Encoding).  But with dynamic font subsetting a single TTFont
-will result in a number of Font/FontDescriptor/Encoding object sets, and the
-contents of those will depend on the actual characters used for printing.
-
-To support dynamic font subsetting a concept of &quot;dynamic font&quot; was introduced.
-Dynamic Fonts have a _dynamicFont attribute set to 1.
-
-Dynamic fonts have the following additional functions::
-
-    def splitString(self, text, doc):
-        '''Splits text into a number of chunks, each of which belongs to a
-        single subset.  Returns a list of tuples (subset, string).  Use
-        subset numbers with getSubsetInternalName.  Doc is used to identify
-        a document so that different documents may have different dynamically
-        constructed subsets.'''
-
-    def getSubsetInternalName(self, subset, doc):
-        '''Returns the name of a PDF Font object corresponding to a given
-        subset of this dynamic font.  Use this function instead of
-        PDFDocument.getInternalFontName.'''
-
-You must never call PDFDocument.getInternalFontName for dynamic fonts.
-
-If you have a traditional static font, mapping to PDF text output operators
-is simple::
-
-   '%s 14 Tf (%s) Tj' % (getInternalFontName(psfontname), text)
-
-If you have a dynamic font, use this instead::
-
-   for subset, chunk in font.splitString(text, doc):
-       '%s 14 Tf (%s) Tj' % (font.getSubsetInternalName(subset, doc), chunk)
-
-(Tf is a font setting operator and Tj is a text ouput operator.  You should
-also escape invalid characters in Tj argument, see TextObject._formatText.
-Oh, and that 14 up there is font size.)
-
-Canvas and TextObject have special support for dynamic fonts.
-&quot;&quot;&quot;
-
-import string
-from struct import pack, unpack, error as structError
-from reportlab.lib.utils import getStringIO
-from reportlab.pdfbase import pdfmetrics, pdfdoc
-
-class TTFError(pdfdoc.PDFError):
-    &quot;TrueType font exception&quot;
-    pass
-
-
-def SUBSETN(n,table=string.maketrans('0123456789','ABCDEFGHIJ')):
-    return ('%6.6d'%n).translate(table)
-#
-# Helpers
-#
-
-from codecs import utf_8_encode, utf_8_decode, latin_1_decode
-parse_utf8=lambda x, decode=utf_8_decode: map(ord,decode(x)[0])
-parse_latin1 = lambda x, decode=latin_1_decode: map(ord,decode(x)[0])
-def latin1_to_utf8(text):
-    &quot;helper to convert when needed from latin input&quot;
-    return utf_8_encode(latin_1_decode(text)[0])[0]
-
-def makeToUnicodeCMap(fontname, subset):
-    &quot;&quot;&quot;Creates a ToUnicode CMap for a given subset.  See Adobe
-    _PDF_Reference (ISBN 0-201-75839-3) for more information.&quot;&quot;&quot;
-    cmap = [
-        &quot;/CIDInit /ProcSet findresource begin&quot;,
-        &quot;12 dict begin&quot;,
-        &quot;begincmap&quot;,
-        &quot;/CIDSystemInfo&quot;,
-        &quot;&lt;&lt; /Registry (%s)&quot; % fontname,
-        &quot;/Ordering (%s)&quot; % fontname,
-        &quot;/Supplement 0&quot;,
-        &quot;&gt;&gt; def&quot;,
-        &quot;/CMapName /%s def&quot; % fontname,
-        &quot;/CMapType 2 def&quot;,
-        &quot;1 begincodespacerange&quot;,
-        &quot;&lt;00&gt; &lt;%02X&gt;&quot; % (len(subset) - 1),
-        &quot;endcodespacerange&quot;,
-        &quot;%d beginbfchar&quot; % len(subset)
-        ] + [&quot;&lt;%02X&gt; &lt;%04X&gt;&quot; % (i,v) for i,v in enumerate(subset)] + [
-        &quot;endbfchar&quot;,
-        &quot;endcmap&quot;,
-        &quot;CMapName currentdict /CMap defineresource pop&quot;,
-        &quot;end&quot;,
-        &quot;end&quot;
-        ]
-    return string.join(cmap, &quot;\n&quot;)
-
-def splice(stream, offset, value):
-    &quot;&quot;&quot;Splices the given value into stream at the given offset and
-    returns the resulting stream (the original is unchanged)&quot;&quot;&quot;
-    return stream[:offset] + value + stream[offset + len(value):]
-
-def _set_ushort(stream, offset, value):
-    &quot;&quot;&quot;Writes the given unsigned short value into stream at the given
-    offset and returns the resulting stream (the original is unchanged)&quot;&quot;&quot;
-    return splice(stream, offset, pack(&quot;&gt;H&quot;, value))
-
-try:
-    import _rl_accel
-except ImportError:
-    try:
-        from reportlab.lib import _rl_accel
-    except ImportError:
-        _rl_accel = None
-
-try:
-    hex32 = _rl_accel.hex32
-except:
-    def hex32(i):
-        return '0X%8.8X' % (long(i)&amp;0xFFFFFFFFL)
-try:
-    add32 = _rl_accel.add32L
-    calcChecksum = _rl_accel.calcChecksumL
-except:
-    def add32(x, y):
-        &quot;Calculate (x + y) modulo 2**32&quot;
-        return (x+y) &amp; 0xFFFFFFFFL
-
-    def calcChecksum(data):
-        &quot;&quot;&quot;Calculates TTF-style checksums&quot;&quot;&quot;
-        if len(data)&amp;3: data = data + (4-(len(data)&amp;3))*&quot;\0&quot;
-        return sum(unpack(&quot;&gt;%dl&quot; % (len(data)&gt;&gt;2), data)) &amp; 0xFFFFFFFFL
-del _rl_accel
-#
-# TrueType font handling
-#
-
-GF_ARG_1_AND_2_ARE_WORDS        = 1 &lt;&lt; 0
-GF_ARGS_ARE_XY_VALUES           = 1 &lt;&lt; 1
-GF_ROUND_XY_TO_GRID             = 1 &lt;&lt; 2
-GF_WE_HAVE_A_SCALE              = 1 &lt;&lt; 3
-GF_RESERVED                     = 1 &lt;&lt; 4
-GF_MORE_COMPONENTS              = 1 &lt;&lt; 5
-GF_WE_HAVE_AN_X_AND_Y_SCALE     = 1 &lt;&lt; 6
-GF_WE_HAVE_A_TWO_BY_TWO         = 1 &lt;&lt; 7
-GF_WE_HAVE_INSTRUCTIONS         = 1 &lt;&lt; 8
-GF_USE_MY_METRICS               = 1 &lt;&lt; 9
-GF_OVERLAP_COMPOUND             = 1 &lt;&lt; 10
-GF_SCALED_COMPONENT_OFFSET      = 1 &lt;&lt; 11
-GF_UNSCALED_COMPONENT_OFFSET    = 1 &lt;&lt; 12
-
-def TTFOpenFile(fn):
-    '''Opens a TTF file possibly after searching TTFSearchPath
-    returns (filename,file)
-    '''
-    from reportlab.lib.utils import rl_isfile, open_for_read
-    try:
-        f = open_for_read(fn,'rb')
-        return fn, f
-    except IOError:
-        import os
-        if not os.path.isabs(fn):
-            from reportlab import rl_config
-            for D in rl_config.TTFSearchPath:
-                tfn = os.path.join(D,fn)
-                if rl_isfile(tfn):
-                    f = open_for_read(tfn,'rb')
-                    return tfn, f
-        raise TTFError('Can\'t open file &quot;%s&quot;' % D)
-
-class TTFontParser:
-    &quot;Basic TTF file parser&quot;
-    ttfVersions = (0x00010000,0x74727565,0x74746366)
-    ttcVersions = (0x00010000,0x00020000)
-    fileKind='TTF'
-
-    def __init__(self, file, validate=0,subfontIndex=0):
-        &quot;&quot;&quot;Loads and parses a TrueType font file.  file can be a filename or a
-        file object.  If validate is set to a false values, skips checksum
-        validation.  This can save time, especially if the font is large.
-        &quot;&quot;&quot;
-        self.validate = validate
-        self.readFile(file)
-        isCollection = self.readHeader()
-        if isCollection:
-            self.readTTCHeader()
-            self.getSubfont(subfontIndex)
-        else:
-            if self.validate: self.checksumFile()
-            self.readTableDirectory()
-            self.subfontNameX = ''
-
-    def readTTCHeader(self):
-        self.ttcVersion = self.read_ulong()
-        self.fileKind = 'TTC'
-        self.ttfVersions = self.ttfVersions[:-1]
-        if self.ttcVersion not in self.ttcVersions: 
-            raise TTFError('&quot;%s&quot; is not a %s file: can\'t read version 0x%8.8x' %(self.filename,self.fileKind,self.ttcVersion))
-        self.numSubfonts = self.read_ulong()
-        self.subfontOffsets = []
-        a = self.subfontOffsets.append
-        for i in xrange(self.numSubfonts):
-            a(self.read_ulong())
-
-    def getSubfont(self,subfontIndex):
-        if self.fileKind!='TTC':
-            raise TTFError('&quot;%s&quot; is not a TTC file: use this method' % (self.filename,self.fileKind))
-        try:
-            pos = self.subfontOffsets[subfontIndex]
-        except IndexError:
-            raise TTFError('TTC file &quot;%s&quot;: bad subfontIndex %s not in [0,%d]' % (self.filename,subfontIndex,self.numSubfonts-1))
-        self.seek(pos)
-        self.readHeader()
-        self.readTableDirectory()
-        self.subfontNameX = '-'+str(subfontIndex)
-
-    def readTableDirectory(self):
-        try:
-            self.numTables = self.read_ushort()
-            self.searchRange = self.read_ushort()
-            self.entrySelector = self.read_ushort()
-            self.rangeShift = self.read_ushort()
-
-            # Read table directory
-            self.table = {}
-            self.tables = []
-            for n in xrange(self.numTables):
-                record = {}
-                record['tag'] = self.read_tag()
-                record['checksum'] = self.read_ulong()
-                record['offset'] = self.read_ulong()
-                record['length'] = self.read_ulong()
-                self.tables.append(record)
-                self.table[record['tag']] = record
-        except:
-            raise TTFError('Corrupt %s file &quot;%s&quot; cannot read Table Directory' % (self.fileKind, self.filename))
-        if self.validate: self.checksumTables()
-
-    def readHeader(self):
-        '''read the sfnt header at the current position'''
-        try:
-            self.version = version = self.read_ulong()
-        except:
-            raise TTFError('&quot;%s&quot; is not a %s file: can\'t read version' %(self.filename,self.fileKind))
-
-        if version==0x4F54544F:
-            raise TTFError('%s file &quot;%s&quot;: postscript outlines are not supported'%(self.fileKind,self.filename))
-
-        if version not in self.ttfVersions:
-            raise TTFError('Not a TrueType font: version=0x%8.8X' % version)
-        return version==self.ttfVersions[-1]
-
-    def readFile(self,f):
-        if hasattr(f,'read'):
-            self.filename = '(ttf)'
-        else:
-            self.filename, f = TTFOpenFile(f)
-
-        self._ttf_data = f.read()
-        self._pos = 0
-
-    def checksumTables(self):
-        # Check the checksums for all tables
-        for t in self.tables:
-            table = self.get_chunk(t['offset'], t['length'])
-            checksum = calcChecksum(table)
-            if t['tag'] == 'head':
-                adjustment = unpack('&gt;l', table[8:8+4])[0]
-                checksum = add32(checksum, -adjustment)
-            xchecksum = t['checksum']
-            if xchecksum != checksum:
-                raise TTFError('TTF file &quot;%s&quot;: invalid checksum %s table: %s (expected %s)' % (self.filename,hex32(checksum),t['tag'],hex32(xchecksum)))
-
-    def checksumFile(self):
-        # Check the checksums for the whole file
-        checksum = calcChecksum(self._ttf_data)
-        if 0xB1B0AFBAL!=checksum:
-            raise TTFError('TTF file &quot;%s&quot;: invalid checksum %s (expected 0xB1B0AFBA) len: %d &amp;3: %d' % (self.filename,hex32(checksum),len(self._ttf_data),(len(self._ttf_data)&amp;3)))
-
-    def get_table_pos(self, tag):
-        &quot;Returns the offset and size of a given TTF table.&quot;
-        offset = self.table[tag]['offset']
-        length = self.table[tag]['length']
-        return (offset, length)
-
-    def seek(self, pos):
-        &quot;Moves read pointer to a given offset in file.&quot;
-        self._pos = pos
-
-    def skip(self, delta):
-        &quot;Skip the given number of bytes.&quot;
-        self._pos = self._pos + delta
-
-    def seek_table(self, tag, offset_in_table = 0):
-        &quot;&quot;&quot;Moves read pointer to the given offset within a given table and
-        returns absolute offset of that position in the file.&quot;&quot;&quot;
-        self._pos = self.get_table_pos(tag)[0] + offset_in_table
-        return self._pos
-
-    def read_tag(self):
-        &quot;Read a 4-character tag&quot;
-        self._pos += 4
-        return self._ttf_data[self._pos - 4:self._pos]
-
-    def read_ushort(self):
-        &quot;Reads an unsigned short&quot;
-        self._pos += 2
-        return unpack('&gt;H',self._ttf_data[self._pos-2:self._pos])[0]
-
-    def read_ulong(self):
-        &quot;Reads an unsigned long&quot;
-        self._pos += 4
-        return unpack('&gt;L',self._ttf_data[self._pos - 4:self._pos])[0]
-
-    def read_short(self):
-        &quot;Reads a signed short&quot;
-        self._pos += 2
-        try:
-            return unpack('&gt;h',self._ttf_data[self._pos-2:self._pos])[0]
-        except structError, error:
-            raise TTFError, error
-
-    def get_ushort(self, pos):
-        &quot;Return an unsigned short at given position&quot;
-        return unpack('&gt;H',self._ttf_data[pos:pos+2])[0]
-
-    def get_ulong(self, pos):
-        &quot;Return an unsigned long at given position&quot;
-        return unpack('&gt;L',self._ttf_data[pos:pos+4])[0]
-
-    def get_chunk(self, pos, length):
-        &quot;Return a chunk of raw data at given position&quot;
-        return self._ttf_data[pos:pos+length]
-
-    def get_table(self, tag):
-        &quot;Return the given TTF table&quot;
-        pos, length = self.get_table_pos(tag)
-        return self._ttf_data[pos:pos+length]
-
-class TTFontMaker:
-    &quot;Basic TTF file generator&quot;
-
-    def __init__(self):
-        &quot;Initializes the generator.&quot;
-        self.tables = {}
-
-    def add(self, tag, data):
-        &quot;Adds a table to the TTF file.&quot;
-        if tag == 'head':
-            data = splice(data, 8, '\0\0\0\0')
-        self.tables[tag] = data
-
-    def makeStream(self):
-        &quot;Finishes the generation and returns the TTF file as a string&quot;
-        stm = getStringIO()
-        write = stm.write
-
-        numTables = len(self.tables)
-        searchRange = 1
-        entrySelector = 0
-        while searchRange * 2 &lt;= numTables:
-            searchRange = searchRange * 2
-            entrySelector = entrySelector + 1
-        searchRange = searchRange * 16
-        rangeShift = numTables * 16 - searchRange
-
-        # Header
-        write(pack(&quot;&gt;lHHHH&quot;, 0x00010000, numTables, searchRange,
-                                 entrySelector, rangeShift))
-
-        # Table directory
-        tables = self.tables.items()
-        tables.sort()     # XXX is this the correct order?
-        offset = 12 + numTables * 16
-        for tag, data in tables:
-            if tag == 'head':
-                head_start = offset
-            checksum = calcChecksum(data)
-            write(tag)
-            write(pack(&quot;&gt;LLL&quot;, checksum, offset, len(data)))
-            paddedLength = (len(data)+3)&amp;~3
-            offset = offset + paddedLength
-
-        # Table data
-        for tag, data in tables:
-            data += &quot;\0\0\0&quot;
-            write(data[:len(data)&amp;~3])
-
-        checksum = calcChecksum(stm.getvalue())
-        checksum = add32(0xB1B0AFBAL, -checksum)
-        stm.seek(head_start + 8)
-        write(pack('&gt;L', checksum))
-
-        return stm.getvalue()
-
-class TTFontFile(TTFontParser):
-    &quot;TTF file parser and generator&quot;
-
-    def __init__(self, file, charInfo=1, validate=0,subfontIndex=0):
-        &quot;&quot;&quot;Loads and parses a TrueType font file.
-
-        file can be a filename or a file object.  If validate is set to a false
-        values, skips checksum validation.  This can save time, especially if
-        the font is large.  See TTFontFile.extractInfo for more information.
-        &quot;&quot;&quot;
-        TTFontParser.__init__(self, file, validate=validate,subfontIndex=subfontIndex)
-        self.extractInfo(charInfo)
-
-    def extractInfo(self, charInfo=1):
-        &quot;&quot;&quot;
-        Extract typographic information from the loaded font file.
-
-        The following attributes will be set::
-        
-            name         PostScript font name
-            flags        Font flags
-            ascent       Typographic ascender in 1/1000ths of a point
-            descent      Typographic descender in 1/1000ths of a point
-            capHeight    Cap height in 1/1000ths of a point (0 if not available)
-            bbox         Glyph bounding box [l,t,r,b] in 1/1000ths of a point
-            _bbox        Glyph bounding box [l,t,r,b] in unitsPerEm
-            unitsPerEm   Glyph units per em
-            italicAngle  Italic angle in degrees ccw
-            stemV        stem weight in 1/1000ths of a point (approximate)
-        
-        If charInfo is true, the following will also be set::
-        
-            defaultWidth   default glyph width in 1/1000ths of a point
-            charWidths     dictionary of character widths for every supported UCS character
-                           code
-        
-        This will only work if the font has a Unicode cmap (platform 3,
-        encoding 1, format 4 or platform 0 any encoding format 4).  Setting
-        charInfo to false avoids this requirement
-        
-        &quot;&quot;&quot;
-        # name - Naming table
-        name_offset = self.seek_table(&quot;name&quot;)
-        format = self.read_ushort()
-        if format != 0:
-            raise TTFError, &quot;Unknown name table format (%d)&quot; % format
-        numRecords = self.read_ushort()
-        string_data_offset = name_offset + self.read_ushort()
-        names = {1:None,2:None,3:None,4:None,6:None}
-        K = names.keys()
-        nameCount = len(names)
-        for i in xrange(numRecords):
-            platformId = self.read_ushort()
-            encodingId = self.read_ushort()
-            languageId = self.read_ushort()
-            nameId = self.read_ushort()
-            length = self.read_ushort()
-            offset = self.read_ushort()
-            if nameId not in K: continue
-            N = None
-            if platformId == 3 and encodingId == 1 and languageId == 0x409: # Microsoft, Unicode, US English, PS Name
-                opos = self._pos
-                try:
-                    self.seek(string_data_offset + offset)
-                    if length % 2 != 0:
-                        raise TTFError, &quot;PostScript name is UTF-16BE string of odd length&quot;
-                    length /= 2
-                    N = []
-                    A = N.append
-                    while length &gt; 0:
-                        char = self.read_ushort()
-                        A(chr(char))
-                        length -= 1
-                    N = ''.join(N)
-                finally:
-                    self._pos = opos
-            elif platformId == 1 and encodingId == 0 and languageId == 0: # Macintosh, Roman, English, PS Name
-                # According to OpenType spec, if PS name exists, it must exist
-                # both in MS Unicode and Macintosh Roman formats.  Apparently,
-                # you can find live TTF fonts which only have Macintosh format.
-                N = self.get_chunk(string_data_offset + offset, length)
-            if N and names[nameId]==None:
-                names[nameId] = N
-                nameCount -= 1
-                if nameCount==0: break
-        if names[6] is not None:
-            psName = names[6].replace(&quot; &quot;, &quot;-&quot;)  #Dinu Gherman's fix for font names with spaces
-        elif names[4] is not None:
-            psName = names[4].replace(&quot; &quot;, &quot;-&quot;)
-        # Fine, one last try before we bail.
-        elif names[1] is not None:
-            psName = names[1].replace(&quot; &quot;, &quot;-&quot;)
-        else:
-            psName = None
-
-        # Don't just assume, check for None since some shoddy fonts cause crashes here...
-        if not psName:
-            raise TTFError, &quot;Could not find PostScript font name&quot;
-        for c in psName:
-            oc = ord(c)
-            if oc&gt;126 or c in ' [](){}&lt;&gt;/%':
-                raise TTFError, &quot;psName=%r contains invalid character '%s' ie U+%04X&quot; % (psName,c,ord(c))
-        self.name = psName
-        self.familyName = names[1] or psName
-        self.styleName = names[2] or 'Regular'
-        self.fullName = names[4] or psName
-        self.uniqueFontID = names[3] or psName
-
-        # head - Font header table
-        self.seek_table(&quot;head&quot;)
-        ver_maj, ver_min = self.read_ushort(), self.read_ushort()
-        if ver_maj != 1:
-            raise TTFError, 'Unknown head table version %d.%04x' % (ver_maj, ver_min)
-        self.fontRevision = self.read_ushort(), self.read_ushort()
-
-        self.skip(4)
-        magic = self.read_ulong()
-        if magic != 0x5F0F3CF5:
-            raise TTFError, 'Invalid head table magic %04x' % magic
-        self.skip(2)
-        self.unitsPerEm = unitsPerEm = self.read_ushort()
-        scale = lambda x, unitsPerEm=unitsPerEm: x * 1000. / unitsPerEm
-        self.skip(16)
-        xMin = self.read_short()
-        yMin = self.read_short()
-        xMax = self.read_short()
-        yMax = self.read_short()
-        self.bbox = map(scale, [xMin, yMin, xMax, yMax])
-        self.skip(3*2)
-        indexToLocFormat = self.read_ushort()
-        glyphDataFormat = self.read_ushort()
-
-        # OS/2 - OS/2 and Windows metrics table
-        # (needs data from head table)
-        if self.table.has_key(&quot;OS/2&quot;):
-            self.seek_table(&quot;OS/2&quot;)
-            version = self.read_ushort()
-            self.skip(2)
-            usWeightClass = self.read_ushort()
-            self.skip(2)
-            fsType = self.read_ushort()
-            if fsType == 0x0002 or (fsType &amp; 0x0300) != 0:
-                raise TTFError, 'Font does not allow subsetting/embedding (%04X)' % fsType
-            self.skip(58)   #11*2 + 10 + 4*4 + 4 + 3*2
-            sTypoAscender = self.read_short()
-            sTypoDescender = self.read_short()
-            self.ascent = scale(sTypoAscender)      # XXX: for some reason it needs to be multiplied by 1.24--1.28
-            self.descent = scale(sTypoDescender)
-
-            if version &gt; 1:
-                self.skip(16)   #3*2 + 2*4 + 2
-                sCapHeight = self.read_short()
-                self.capHeight = scale(sCapHeight)
-            else:
-                self.capHeight = self.ascent
-        else:
-            # Microsoft TTFs require an OS/2 table; Apple ones do not.  Try to
-            # cope.  The data is not very important anyway.
-            usWeightClass = 500
-            self.ascent = scale(yMax)
-            self.descent = scale(yMin)
-            self.capHeight = self.ascent
-
-        # There's no way to get stemV from a TTF file short of analyzing actual outline data
-        # This fuzzy formula is taken from pdflib sources, but we could just use 0 here
-        self.stemV = 50 + int((usWeightClass / 65.0) ** 2)
-
-        # post - PostScript table
-        # (needs data from OS/2 table)
-        self.seek_table(&quot;post&quot;)
-        ver_maj, ver_min = self.read_ushort(), self.read_ushort()
-        if ver_maj not in (1, 2, 3, 4):
-            # Adobe/MS documents 1, 2, 2.5, 3; Apple also has 4.
-            # From Apple docs it seems that we do not need to care
-            # about the exact version, so if you get this error, you can
-            # try to remove this check altogether.
-            raise TTFError, 'Unknown post table version %d.%04x' % (ver_maj, ver_min)
-        self.italicAngle = self.read_short() + self.read_ushort() / 65536.0
-        self.underlinePosition = self.read_short()
-        self.underlineThickness = self.read_short()
-        isFixedPitch = self.read_ulong()
-
-        self.flags = FF_SYMBOLIC        # All fonts that contain characters
-                                        # outside the original Adobe character
-                                        # set are considered &quot;symbolic&quot;.
-        if self.italicAngle!= 0:
-            self.flags = self.flags | FF_ITALIC
-        if usWeightClass &gt;= 600:        # FW_REGULAR == 500, FW_SEMIBOLD == 600
-            self.flags = self.flags | FF_FORCEBOLD
-        if isFixedPitch:
-            self.flags = self.flags | FF_FIXED
-        # XXX: FF_SERIF?  FF_SCRIPT?  FF_ALLCAP?  FF_SMALLCAP?
-
-        # hhea - Horizontal header table
-        self.seek_table(&quot;hhea&quot;)
-        ver_maj, ver_min = self.read_ushort(), self.read_ushort()
-        if ver_maj != 1:
-            raise TTFError, 'Unknown hhea table version %d.%04x' % (ver_maj, ver_min)
-        self.skip(28)
-        metricDataFormat = self.read_ushort()
-        if metricDataFormat != 0:
-            raise TTFError, 'Unknown horizontal metric data format (%d)' % metricDataFormat
-        numberOfHMetrics = self.read_ushort()
-        if numberOfHMetrics == 0:
-            raise TTFError, 'Number of horizontal metrics is 0'
-
-        # maxp - Maximum profile table
-        self.seek_table(&quot;maxp&quot;)
-        ver_maj, ver_min = self.read_ushort(), self.read_ushort()
-        if ver_maj != 1:
-            raise TTFError, 'Unknown maxp table version %d.%04x' % (ver_maj, ver_min)
-        numGlyphs = self.read_ushort()
-
-        if not charInfo:
-            self.charToGlyph = None
-            self.defaultWidth = None
-            self.charWidths = None
-            return
-
-        if glyphDataFormat != 0:
-            raise TTFError, 'Unknown glyph data format (%d)' % glyphDataFormat
-
-        # cmap - Character to glyph index mapping table
-        cmap_offset = self.seek_table(&quot;cmap&quot;)
-        self.skip(2)
-        cmapTableCount = self.read_ushort()
-        unicode_cmap_offset = None
-        for n in xrange(cmapTableCount):
-            platformID = self.read_ushort()
-            encodingID = self.read_ushort()
-            offset = self.read_ulong()
-            if platformID == 3 and encodingID == 1: # Microsoft, Unicode
-                format = self.get_ushort(cmap_offset + offset)
-                if format == 4:
-                    unicode_cmap_offset = cmap_offset + offset
-                    break
-            elif platformID == 0: # Unicode -- assume all encodings are compatible
-                format = self.get_ushort(cmap_offset + offset)
-                if format == 4:
-                    unicode_cmap_offset = cmap_offset + offset
-                    break
-        if unicode_cmap_offset is None:
-            raise TTFError, 'Font does not have cmap for Unicode (platform 3, encoding 1, format 4 or platform 0 any encoding format 4)'
-        self.seek(unicode_cmap_offset + 2)
-        length = self.read_ushort()
-        limit = unicode_cmap_offset + length
-        self.skip(2)
-        segCount = self.read_ushort() / 2
-        self.skip(6)
-        endCount = map(lambda x, self=self: self.read_ushort(), xrange(segCount))
-        self.skip(2)
-        startCount = map(lambda x, self=self: self.read_ushort(), xrange(segCount))
-        idDelta = map(lambda x, self=self: self.read_short(), xrange(segCount))
-        idRangeOffset_start = self._pos
-        idRangeOffset = map(lambda x, self=self: self.read_ushort(), xrange(segCount))
-
-        # Now it gets tricky.
-        glyphToChar = {}
-        charToGlyph = {}
-        for n in xrange(segCount):
-            for unichar in xrange(startCount[n], endCount[n] + 1):
-                if idRangeOffset[n] == 0:
-                    glyph = (unichar + idDelta[n]) &amp; 0xFFFF
-                else:
-                    offset = (unichar - startCount[n]) * 2 + idRangeOffset[n]
-                    offset = idRangeOffset_start + 2 * n + offset
-                    if offset &gt;= limit:
-                        # workaround for broken fonts (like Thryomanes)
-                        glyph = 0
-                    else:
-                        glyph = self.get_ushort(offset)
-                        if glyph != 0:
-                            glyph = (glyph + idDelta[n]) &amp; 0xFFFF
-                charToGlyph[unichar] = glyph
-                if glyphToChar.has_key(glyph):
-                    glyphToChar[glyph].append(unichar)
-                else:
-                    glyphToChar[glyph] = [unichar]
-        self.charToGlyph = charToGlyph
-
-        # hmtx - Horizontal metrics table
-        # (needs data from hhea, maxp, and cmap tables)
-        self.seek_table(&quot;hmtx&quot;)
-        aw = None
-        self.charWidths = {}
-        self.hmetrics = []
-        for glyph in xrange(numberOfHMetrics):
-            # advance width and left side bearing.  lsb is actually signed
-            # short, but we don't need it anyway (except for subsetting)
-            aw, lsb = self.read_ushort(), self.read_ushort()
-            self.hmetrics.append((aw, lsb))
-            aw = scale(aw)
-            if glyph == 0:
-                self.defaultWidth = aw
-            if glyphToChar.has_key(glyph):
-                for char in glyphToChar[glyph]:
-                    self.charWidths[char] = aw
-        for glyph in xrange(numberOfHMetrics, numGlyphs):
-            # the rest of the table only lists advance left side bearings.
-            # so we reuse aw set by the last iteration of the previous loop
-            lsb = self.read_ushort()
-            self.hmetrics.append((aw, lsb))
-            if glyphToChar.has_key(glyph):
-                for char in glyphToChar[glyph]:
-                    self.charWidths[char] = aw
-
-        # loca - Index to location
-        self.seek_table('loca')
-        self.glyphPos = []
-        if indexToLocFormat == 0:
-            for n in xrange(numGlyphs + 1):
-                self.glyphPos.append(self.read_ushort() &lt;&lt; 1)
-        elif indexToLocFormat == 1:
-            for n in xrange(numGlyphs + 1):
-                self.glyphPos.append(self.read_ulong())
-        else:
-            raise TTFError, 'Unknown location table format (%d)' % indexToLocFormat
-
-    # Subsetting
-
-    def makeSubset(self, subset):
-        &quot;&quot;&quot;Create a subset of a TrueType font&quot;&quot;&quot;
-        output = TTFontMaker()
-
-        # Build a mapping of glyphs in the subset to glyph numbers in
-        # the original font.  Also build a mapping of UCS codes to
-        # glyph values in the new font.
-
-        # Start with 0 -&gt; 0: &quot;missing character&quot;
-        glyphMap = [0]                  # new glyph index -&gt; old glyph index
-        glyphSet = {0:0}                # old glyph index -&gt; new glyph index
-        codeToGlyph = {}                # unicode -&gt; new glyph index
-        for code in subset:
-            if self.charToGlyph.has_key(code):
-                originalGlyphIdx = self.charToGlyph[code]
-            else:
-                originalGlyphIdx = 0
-            if not glyphSet.has_key(originalGlyphIdx):
-                glyphSet[originalGlyphIdx] = len(glyphMap)
-                glyphMap.append(originalGlyphIdx)
-            codeToGlyph[code] = glyphSet[originalGlyphIdx]
-
-        # Also include glyphs that are parts of composite glyphs
-        start = self.get_table_pos('glyf')[0]
-        n = 0
-        while n &lt; len(glyphMap):
-            originalGlyphIdx = glyphMap[n]
-            glyphPos = self.glyphPos[originalGlyphIdx]
-            glyphLen = self.glyphPos[originalGlyphIdx + 1] - glyphPos
-            n += 1
-            if not glyphLen: continue
-            self.seek(start + glyphPos)
-            numberOfContours = self.read_short()
-            if numberOfContours &lt; 0:
-                # composite glyph
-                self.skip(8)
-                flags = GF_MORE_COMPONENTS
-                while flags &amp; GF_MORE_COMPONENTS:
-                    flags = self.read_ushort()
-                    glyphIdx = self.read_ushort()
-                    if not glyphSet.has_key(glyphIdx):
-                        glyphSet[glyphIdx] = len(glyphMap)
-                        glyphMap.append(glyphIdx)
-                    if flags &amp; GF_ARG_1_AND_2_ARE_WORDS:
-                        self.skip(4)
-                    else:
-                        self.skip(2)
-                    if flags &amp; GF_WE_HAVE_A_SCALE:
-                        self.skip(2)
-                    elif flags &amp; GF_WE_HAVE_AN_X_AND_Y_SCALE:
-                        self.skip(4)
-                    elif flags &amp; GF_WE_HAVE_A_TWO_BY_TWO:
-                        self.skip(8)
-
-        numGlyphs = n = len(glyphMap)
-        while n &gt; 1 and self.hmetrics[n][0] == self.hmetrics[n - 1][0]:
-            n -= 1
-        numberOfHMetrics = n
-
-        # The following tables are simply copied from the original
-        for tag in ('name', 'OS/2', 'cvt ', 'fpgm', 'prep'):
-            try:
-                output.add(tag, self.get_table(tag))
-            except KeyError:
-                # Apparently some of the tables are optional (cvt, fpgm, prep).
-                # The lack of the required ones (name, OS/2) would have already
-                # been caught before.
-                pass
-
-        # post - PostScript
-        post = &quot;\x00\x03\x00\x00&quot; + self.get_table('post')[4:16] + &quot;\x00&quot; * 16
-        output.add('post', post)
-
-        # hhea - Horizontal Header
-        hhea = self.get_table('hhea')
-        hhea = _set_ushort(hhea, 34, numberOfHMetrics)
-        output.add('hhea', hhea)
-
-        # maxp - Maximum Profile
-        maxp = self.get_table('maxp')
-        maxp = _set_ushort(maxp, 4, numGlyphs)
-        output.add('maxp', maxp)
-
-        # cmap - Character to glyph mapping
-        # XXX maybe use format 0 if possible, not 6?
-        entryCount = len(subset)
-        length = 10 + entryCount * 2
-        cmap = [0, 1,           # version, number of tables
-                1, 0, 0,12,     # platform, encoding, offset (hi,lo)
-                6, length, 0,   # format, length, language
-                0,
-                entryCount] + \
-               map(codeToGlyph.get, subset)
-        cmap = apply(pack, [&quot;&gt;%dH&quot; % len(cmap)] + cmap)
-        output.add('cmap', cmap)
-
-        # hmtx - Horizontal Metrics
-        hmtx = []
-        for n in xrange(numGlyphs):
-            originalGlyphIdx = glyphMap[n]
-            aw, lsb = self.hmetrics[originalGlyphIdx]
-            if n &lt; numberOfHMetrics:
-                hmtx.append(int(aw))
-            hmtx.append(int(lsb))
-        hmtx = apply(pack, [&quot;&gt;%dH&quot; % len(hmtx)] + hmtx)
-        output.add('hmtx', hmtx)
-
-        # glyf - Glyph data
-        glyphData = self.get_table('glyf')
-        offsets = []
-        glyf = []
-        pos = 0
-        for n in xrange(numGlyphs):
-            offsets.append(pos)
-            originalGlyphIdx = glyphMap[n]
-            glyphPos = self.glyphPos[originalGlyphIdx]
-            glyphLen = self.glyphPos[originalGlyphIdx + 1] - glyphPos
-            data = glyphData[glyphPos:glyphPos+glyphLen]
-            # Fix references in composite glyphs
-            if glyphLen &gt; 2 and unpack(&quot;&gt;h&quot;, data[:2])[0] &lt; 0:
-                # composite glyph
-                pos_in_glyph = 10
-                flags = GF_MORE_COMPONENTS
-                while flags &amp; GF_MORE_COMPONENTS:
-                    flags = unpack(&quot;&gt;H&quot;, data[pos_in_glyph:pos_in_glyph+2])[0]
-                    glyphIdx = unpack(&quot;&gt;H&quot;, data[pos_in_glyph+2:pos_in_glyph+4])[0]
-                    data = _set_ushort(data, pos_in_glyph + 2, glyphSet[glyphIdx])
-                    pos_in_glyph = pos_in_glyph + 4
-                    if flags &amp; GF_ARG_1_AND_2_ARE_WORDS:
-                        pos_in_glyph = pos_in_glyph + 4
-                    else:
-                        pos_in_glyph = pos_in_glyph + 2
-                    if flags &amp; GF_WE_HAVE_A_SCALE:
-                        pos_in_glyph = pos_in_glyph + 2
-                    elif flags &amp; GF_WE_HAVE_AN_X_AND_Y_SCALE:
-                        pos_in_glyph = pos_in_glyph + 4
-                    elif flags &amp; GF_WE_HAVE_A_TWO_BY_TWO:
-                        pos_in_glyph = pos_in_glyph + 8
-            glyf.append(data)
-            pos = pos + glyphLen
-            if pos % 4 != 0:
-                padding = 4 - pos % 4
-                glyf.append('\0' * padding)
-                pos = pos + padding
-        offsets.append(pos)
-        output.add('glyf', string.join(glyf, &quot;&quot;))
-
-        # loca - Index to location
-        loca = []
-        if (pos + 1) &gt;&gt; 1 &gt; 0xFFFF:
-            indexToLocFormat = 1        # long format
-            for offset in offsets:
-                loca.append(offset)
-            loca = apply(pack, [&quot;&gt;%dL&quot; % len(loca)] + loca)
-        else:
-            indexToLocFormat = 0        # short format
-            for offset in offsets:
-                loca.append(offset &gt;&gt; 1)
-            loca = apply(pack, [&quot;&gt;%dH&quot; % len(loca)] + loca)
-        output.add('loca', loca)
-
-        # head - Font header
-        head = self.get_table('head')
-        head = _set_ushort(head, 50, indexToLocFormat)
-        output.add('head', head)
-
-        return output.makeStream()
-
-
-#
-# TrueType font embedding
-#
-
-# PDF font flags (see PDF Reference Guide table 5.19)
-FF_FIXED        = 1 &lt;&lt;  1-1
-FF_SERIF        = 1 &lt;&lt;  2-1
-FF_SYMBOLIC     = 1 &lt;&lt;  3-1
-FF_SCRIPT       = 1 &lt;&lt;  4-1
-FF_NONSYMBOLIC  = 1 &lt;&lt;  6-1
-FF_ITALIC       = 1 &lt;&lt;  7-1
-FF_ALLCAP       = 1 &lt;&lt; 17-1
-FF_SMALLCAP     = 1 &lt;&lt; 18-1
-FF_FORCEBOLD    = 1 &lt;&lt; 19-1
-
-class TTFontFace(TTFontFile, pdfmetrics.TypeFace):
-    &quot;&quot;&quot;TrueType typeface.
-
-    Conceptually similar to a single byte typeface, but the glyphs are
-    identified by UCS character codes instead of glyph names.&quot;&quot;&quot;
-
-    def __init__(self, filename, validate=0, subfontIndex=0):
-        &quot;Loads a TrueType font from filename.&quot;
-        pdfmetrics.TypeFace.__init__(self, None)
-        TTFontFile.__init__(self, filename, validate=validate, subfontIndex=subfontIndex)
-
-    def getCharWidth(self, code):
-        &quot;Returns the width of character U+&lt;code&gt;&quot;
-        return self.charWidths.get(code, self.defaultWidth)
-
-    def addSubsetObjects(self, doc, fontname, subset):
-        &quot;&quot;&quot;Generate a TrueType font subset and add it to the PDF document.
-        Returns a PDFReference to the new FontDescriptor object.&quot;&quot;&quot;
-
-        fontFile = pdfdoc.PDFStream()
-        fontFile.content = self.makeSubset(subset)
-        fontFile.dictionary['Length1'] = len(fontFile.content)
-        if doc.compression:
-            fontFile.filters = [pdfdoc.PDFZCompress]
-        fontFileRef = doc.Reference(fontFile, 'fontFile:%s(%s)' % (self.filename, fontname))
-
-        flags = self.flags &amp; ~ FF_NONSYMBOLIC
-        flags = flags | FF_SYMBOLIC
-
-        fontDescriptor = pdfdoc.PDFDictionary({
-            'Type': '/FontDescriptor',
-            'Ascent': self.ascent,
-            'CapHeight': self.capHeight,
-            'Descent': self.descent,
-            'Flags': flags,
-            'FontBBox': pdfdoc.PDFArray(self.bbox),
-            'FontName': pdfdoc.PDFName(fontname),
-            'ItalicAngle': self.italicAngle,
-            'StemV': self.stemV,
-            'FontFile2': fontFileRef,
-            })
-        return doc.Reference(fontDescriptor, 'fontDescriptor:' + fontname)
-
-class TTEncoding:
-    &quot;&quot;&quot;Encoding for TrueType fonts (always UTF-8).
-
-    TTEncoding does not directly participate in PDF object creation, since
-    we need a number of different 8-bit encodings for every generated font
-    subset.  TTFont itself cares about that.&quot;&quot;&quot;
-
-    def __init__(self):
-        self.name = &quot;UTF-8&quot;
-
-class TTFont:
-    &quot;&quot;&quot;Represents a TrueType font.
-
-    Its encoding is always UTF-8.
-
-    Note: you cannot use the same TTFont object for different documents
-    at the same time.
-
-    Example of usage:
-
-        font = ttfonts.TTFont('PostScriptFontName', '/path/to/font.ttf')
-        pdfmetrics.registerFont(font)
-
-        canvas.setFont('PostScriptFontName', size)
-        canvas.drawString(x, y, &quot;Some text encoded in UTF-8&quot;)
-    &quot;&quot;&quot;
-    class State:
-        namePrefix = 'F'
-        def __init__(self,asciiReadable=1):
-            self.assignments = {}
-            self.nextCode = 0
-            self.internalName = None
-            self.frozen = 0
-
-            if asciiReadable:
-                # Let's add the first 128 unicodes to the 0th subset, so ' '
-                # always has code 32 (for word spacing to work) and the ASCII
-                # output is readable
-                subset0 = range(128)
-                self.subsets = [subset0]
-                for n in subset0:
-                    self.assignments[n] = n
-                self.nextCode = 128
-            else:
-                self.subsets = [[32]*33]
-                self.assignments[32] = 32
-
-    _multiByte = 1      # We want our own stringwidth
-    _dynamicFont = 1    # We want dynamic subsetting
-
-    def __init__(self, name, filename, validate=0, subfontIndex=0,asciiReadable=1):
-        &quot;&quot;&quot;Loads a TrueType font from filename.
-
-        If validate is set to a false values, skips checksum validation.  This
-        can save time, especially if the font is large.
-        &quot;&quot;&quot;
-        self.fontName = name
-        self.face = TTFontFace(filename, validate=validate, subfontIndex=subfontIndex)
-        self.encoding = TTEncoding()
-        from weakref import WeakKeyDictionary
-        self.state = WeakKeyDictionary()
-        self._asciiReadable = asciiReadable
-
-    def _py_stringWidth(self, text, size, encoding='utf-8'):
-        &quot;Calculate text width&quot;
-        if not isinstance(text,unicode):
-            text = unicode(text, encoding or 'utf-8')   # encoding defaults to utf-8
-        g = self.face.charWidths.get
-        dw = self.face.defaultWidth
-        return 0.001*size*sum([g(ord(u),dw) for u in text])
-    stringWidth = _py_stringWidth
-
-    def _assignState(self,doc,asciiReadable=None,namePrefix=None):
-        '''convenience function for those wishing to roll their own state properties'''
-        if asciiReadable is None:
-            asciiReadable = self._asciiReadable
-        try:
-            state = self.state[doc]
-        except KeyError:
-            state = self.state[doc] = TTFont.State(asciiReadable)
-            if namePrefix is not None:
-                state.namePrefix = namePrefix
-        return state
-
-    def splitString(self, text, doc, encoding='utf-8'):
-        &quot;&quot;&quot;Splits text into a number of chunks, each of which belongs to a
-        single subset.  Returns a list of tuples (subset, string).  Use subset
-        numbers with getSubsetInternalName.  Doc is needed for distinguishing
-        subsets when building different documents at the same time.&quot;&quot;&quot;
-        asciiReadable = self._asciiReadable
-        try: state = self.state[doc]
-        except KeyError: state = self.state[doc] = TTFont.State(asciiReadable)
-        curSet = -1
-        cur = []
-        results = []
-        if not isinstance(text,unicode):
-            text = unicode(text, encoding or 'utf-8')   # encoding defaults to utf-8
-        assignments = state.assignments
-        subsets = state.subsets
-        for code in map(ord,text):
-            if assignments.has_key(code):
-                n = assignments[code]
-            else:
-                if state.frozen:
-                    raise pdfdoc.PDFError, &quot;Font %s is already frozen, cannot add new character U+%04X&quot; % (self.fontName, code)
-                n = state.nextCode
-                if n&amp;0xFF==32:
-                    # make code 32 always be a space character
-                    if n!=32: subsets[n &gt;&gt; 8].append(32)
-                    state.nextCode += 1
-                    n = state.nextCode
-                state.nextCode += 1
-                assignments[code] = n
-                if n&gt;32:
-                    if not(n&amp;0xFF): subsets.append([])
-                    subsets[n &gt;&gt; 8].append(code)
-                else:
-                    subsets[0][n] = code
-            if (n &gt;&gt; 8) != curSet:
-                if cur:
-                    results.append((curSet, ''.join(map(chr,cur))))
-                curSet = (n &gt;&gt; 8)
-                cur = []
-            cur.append(n &amp; 0xFF)
-        if cur:
-            results.append((curSet,''.join(map(chr,cur))))
-        return results
-
-    def getSubsetInternalName(self, subset, doc):
-        &quot;&quot;&quot;Returns the name of a PDF Font object corresponding to a given
-        subset of this dynamic font.  Use this function instead of
-        PDFDocument.getInternalFontName.&quot;&quot;&quot;
-        try: state = self.state[doc]
-        except KeyError: state = self.state[doc] = TTFont.State(self._asciiReadable)
-        if subset &lt; 0 or subset &gt;= len(state.subsets):
-            raise IndexError, 'Subset %d does not exist in font %s' % (subset, self.fontName)
-        if state.internalName is None:
-            state.internalName = state.namePrefix +`(len(doc.fontMapping) + 1)`
-            doc.fontMapping[self.fontName] = '/' + state.internalName
-            doc.delayedFonts.append(self)
-        return '/%s+%d' % (state.internalName, subset)
-
-    def addObjects(self, doc):
-        &quot;&quot;&quot;Makes  one or more PDF objects to be added to the document.  The
-        caller supplies the internal name to be used (typically F1, F2, ... in
-        sequence).
-
-        This method creates a number of Font and FontDescriptor objects.  Every
-        FontDescriptor is a (no more than) 256 character subset of the original
-        TrueType font.&quot;&quot;&quot;
-        try: state = self.state[doc]
-        except KeyError: state = self.state[doc] = TTFont.State(self._asciiReadable)
-        state.frozen = 1
-        for n,subset in enumerate(state.subsets):
-            internalName = self.getSubsetInternalName(n, doc)[1:]
-            baseFontName = &quot;%s+%s%s&quot; % (SUBSETN(n),self.face.name,self.face.subfontNameX)
-
-            pdfFont = pdfdoc.PDFTrueTypeFont()
-            pdfFont.__Comment__ = 'Font %s subset %d' % (self.fontName, n)
-            pdfFont.Name = internalName
-            pdfFont.BaseFont = baseFontName
-
-            pdfFont.FirstChar = 0
-            pdfFont.LastChar = len(subset) - 1
-
-            widths = map(self.face.getCharWidth, subset)
-            pdfFont.Widths = pdfdoc.PDFArray(widths)
-
-            cmapStream = pdfdoc.PDFStream()
-            cmapStream.content = makeToUnicodeCMap(baseFontName, subset)
-            if doc.compression:
-                cmapStream.filters = [pdfdoc.PDFZCompress]
-            pdfFont.ToUnicode = doc.Reference(cmapStream, 'toUnicodeCMap:' + baseFontName)
-
-            pdfFont.FontDescriptor = self.face.addSubsetObjects(doc, baseFontName, subset)
-
-            # link it in
-            ref = doc.Reference(pdfFont, internalName)
-            fontDict = doc.idToObject['BasicFonts'].dict
-            fontDict[internalName] = pdfFont
-        del self.state[doc]
-try:
-    from _rl_accel import _instanceStringWidthTTF
-    import new
-    TTFont.stringWidth = new.instancemethod(_instanceStringWidthTTF,None,TTFont)
-except ImportError:
-    pass

commit 8230e4f9eeef0e8ff21a2c5f644052e893f08509
Author: Cristian Garde &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bulmages-main">cristian.garde en gmail.com</A>&gt;
Date:   Thu May 3 11:02:29 2012 +0200

    Arreglado fallo al añadir un campo al Subformulario
    
    Antes ponia 'restricciones |= BlDbField::DbVarChar;' que estaba mal. Corregido por: 'restricciones |= BlDbField::DbNothing;'.
    
    --
    Cristian Garde
    [[[ Trabajando en Bulmages desde Todo-Redes. ]]]
    <A HREF="http://todo-redes.com">http://todo-redes.com</A>

diff --git a/bulmages/bulmalib/src/blsubform.cpp b/bulmages/bulmalib/src/blsubform.cpp
index 761bd87..3761484 100644
--- a/bulmages/bulmalib/src/blsubform.cpp
+++ b/bulmages/bulmalib/src/blsubform.cpp
@@ -355,16 +355,23 @@ void BlSubForm::setMainCompany ( BlMainCompany *emp )
 void BlSubForm::loadSpecs()
 {
     BL_FUNC_DEBUG
-    QFile file ( CONFIG_DIR_CONFIG + m_fileconfig + &quot;_&quot; + mainCompany() -&gt;dbName() + &quot;_specs.spc&quot; );
-    QDomDocument doc ( &quot;mydocument&quot; );
+    
+    QString fileToLoad = CONFIG_DIR_CONFIG + m_fileconfig + &quot;_&quot; + mainCompany() -&gt;dbName() + &quot;_specs.spc&quot;;
+    
+    QFile file ( fileToLoad );
+    
+    /// If not exists return.
     if ( !file.open ( QIODevice::ReadOnly ) ) {
         return;
-    }
+    } // end if
+
+    QDomDocument doc ( &quot;mydocument&quot; );
+
     if ( !doc.setContent ( &amp;file ) ) {
         file.close();
-	
         return;
-    }
+    } // end if
+    
     file.close();
 
     QDomElement docElem = doc.documentElement();
@@ -401,7 +408,7 @@ void BlSubForm::loadSpecs()
             while ( !restrict.isNull() ) {
                 QString trestrict = restrict.text();
                 if ( trestrict == &quot;DBNOTHING&quot; ) {
-                    restricciones |= BlDbField::DbVarChar;
+                    restricciones |= BlDbField::DbNothing;
                 } else if ( trestrict == &quot;DBNOTNULL&quot; ) {
                     restricciones |= BlDbField::DbNotNull;
                 } else if ( trestrict == &quot;DBPRIMARYKEY&quot; ) {
@@ -442,7 +449,6 @@ void BlSubForm::loadSpecs()
         } // end if
     } // end for
 
-    
 }
 
 


<A HREF="https://gitorious.org/bulmages">https://gitorious.org/bulmages</A>
------------------------------------------------------------------------

You are receiving this email because you have chosen to be notified by
email whenever this favorite has new activity. You can manage your
favorite subscriptions at <A HREF="https://gitorious.org/favorites">https://gitorious.org/favorites</A>
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Mensaje anterior: <A HREF="007177.html">[BulmaGés] [Gitorious] Activity: tborras pushed 1	commits to master...
</A></li>
	<LI>Próximo mensaje: <A HREF="007179.html">[BulmaGés] Commits en la lista
</A></li>
         <LI> <B>Mensajes ordenados por:</B> 
              <a href="date.html#7178">[ fecha ]</a>
              <a href="thread.html#7178">[ hilo ]</a>
              <a href="subject.html#7178">[ asunto ]</a>
              <a href="author.html#7178">[ autor ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/bulmages-main">Más información sobre la lista de distribución Bulmages-main </a><br>
</body></html>
